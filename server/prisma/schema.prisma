// Prisma schema for GSAPS backend
// Datasource configured for SQLite (Replit compatible)

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ============================================
// CORE USER MODEL
// ============================================

model User {
  id           Int      @id @default(autoincrement())
  email        String   @unique
  username     String   @unique
  passwordHash String
  name         String
  role         String   @default("member") // member, administrator, moderator
  bio          String?
  avatarUrl    String?
  credentials  String? // e.g., "PhD, Neuroscience"
  verified     Boolean  @default(false)
  xp           Int      @default(0)
  level        Int      @default(1)
  streak       Int      @default(0)
  lastActive   DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  posts             Post[]
  comments          Comment[]
  reactions         Reaction[]
  sentMessages      Message[]        @relation("sentMessages")
  receivedMessages  Message[]        @relation("receivedMessages")
  enrollments       Enrollment[]
  achievements      Achievement[]
  researchAssets    ResearchAsset[]
  paperReviews      PaperReview[]
  groupMemberships  GroupMember[]
  eventAttendances  EventAttendee[]
  ownedGroups       Group[]          @relation("groupOwner")
  createdEvents     Event[]          @relation("eventCreator")
  notifications     Notification[]
}

// ============================================
// SOCIAL FEED
// ============================================

model Post {
  id        Int      @id @default(autoincrement())
  title     String?
  content   String
  tags      String   @default("[]") // JSON array stored as string (SQLite compatibility)
  mediaUrl  String?
  mediaType String? // image, video, link
  authorId  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  author    User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  reactions Reaction[]
  comments  Comment[]
}

model Comment {
  id        Int      @id @default(autoincrement())
  content   String
  authorId  Int
  postId    Int
  parentId  Int? // For nested comments
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  author   User              @relation(fields: [authorId], references: [id], onDelete: Cascade)
  post     Post              @relation(fields: [postId], references: [id], onDelete: Cascade)
  parent   Comment?          @relation("CommentReplies", fields: [parentId], references: [id])
  replies  Comment[]         @relation("CommentReplies")
  reactions CommentReaction[]
}

model Reaction {
  id        Int      @id @default(autoincrement())
  type      String // üëç, ‚ù§Ô∏è, üòÇ, üòÆ, üò¢, üò°, üéâ, ü§î
  userId    Int
  postId    Int
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
}

model CommentReaction {
  id        Int      @id @default(autoincrement())
  type      String
  userId    Int
  commentId Int
  createdAt DateTime @default(now())

  // Relations
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
}

// ============================================
// MESSAGING
// ============================================

model Message {
  id          Int      @id @default(autoincrement())
  body        String
  senderId    Int
  recipientId Int
  read        Boolean  @default(false)
  createdAt   DateTime @default(now())

  // Relations
  sender    User @relation("sentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  recipient User @relation("receivedMessages", fields: [recipientId], references: [id], onDelete: Cascade)
}

// ============================================
// GROUPS
// ============================================

model Group {
  id          Int      @id @default(autoincrement())
  name        String
  description String
  coverUrl    String?
  privacy     String   @default("public") // public, private
  category    String? // research, support, professional, etc.
  ownerId     Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  owner   User          @relation("groupOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members GroupMember[]
}

model GroupMember {
  id       Int      @id @default(autoincrement())
  userId   Int
  groupId  Int
  role     String   @default("member") // member, admin, moderator
  joinedAt DateTime @default(now())

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
}

// ============================================
// EVENTS
// ============================================

model Event {
  id          Int      @id @default(autoincrement())
  title       String
  description String
  location    String?
  isVirtual   Boolean  @default(false)
  virtualUrl  String?
  startDate   DateTime
  endDate     DateTime
  coverUrl    String?
  category    String? // conference, workshop, webinar, social
  maxAttendees Int?
  creatorId   Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  creator   User            @relation("eventCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  attendees EventAttendee[]
}

model EventAttendee {
  id        Int      @id @default(autoincrement())
  userId    Int
  eventId   Int
  status    String   @default("going") // going, interested, not_going
  createdAt DateTime @default(now())

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
}

// ============================================
// LEARNING MANAGEMENT SYSTEM
// ============================================

model Course {
  id          Int      @id @default(autoincrement())
  title       String
  description String
  category    String?
  level       String   @default("beginner") // beginner, intermediate, advanced
  thumbnailUrl String?
  duration    Int? // in minutes
  ceCredits   Float?
  ceType      String? // APA, CME, CNE
  instructorName String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  enrollments Enrollment[]
  lessons     Lesson[]
}

model Lesson {
  id          Int      @id @default(autoincrement())
  courseId    Int
  title       String
  description String?
  contentUrl  String?
  contentType String   @default("video") // video, text, quiz
  duration    Int? // in minutes
  orderIndex  Int      @default(0)
  createdAt   DateTime @default(now())

  // Relations
  course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
}

model Enrollment {
  id        Int      @id @default(autoincrement())
  userId    Int
  courseId  Int
  status    String   @default("enrolled") // enrolled, completed, dropped
  progress  Int      @default(0) // 0-100
  startedAt DateTime @default(now())
  completedAt DateTime?
  updatedAt DateTime @updatedAt

  // Relations
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)

  @@unique([userId, courseId])
}

// ============================================
// RESEARCH LIBRARY
// ============================================

model ResearchAsset {
  id            Int      @id @default(autoincrement())
  title         String
  description   String
  url           String
  type          String // paper, dataset, document, presentation
  authors       String   @default("[]") // JSON array
  publishedDate DateTime?
  journal       String?
  doi           String?
  abstract      String?
  keywords      String   @default("[]") // JSON array
  citationCount Int      @default(0)
  downloadCount Int      @default(0)
  ownerId       Int
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  owner   User          @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  reviews PaperReview[]
}

model PaperReview {
  id        Int      @id @default(autoincrement())
  assetId   Int
  userId    Int
  rating    Int // 1-5
  review    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  asset ResearchAsset @relation(fields: [assetId], references: [id], onDelete: Cascade)
  user  User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([assetId, userId])
}

// ============================================
// GAMIFICATION
// ============================================

model Achievement {
  id        Int      @id @default(autoincrement())
  userId    Int
  type      String // first_post, helpful_answer, course_completed, etc.
  name      String
  description String?
  iconUrl   String?
  points    Int      @default(0)
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id        Int      @id @default(autoincrement())
  userId    Int
  type      String // reaction, comment, message, achievement, event, etc.
  title     String
  body      String?
  data      String   @default("{}") // JSON object for additional data
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}
